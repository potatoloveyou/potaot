<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    class Animal {
      constructor(name, shouting) {
        this.name = name;
        this.shouting = shouting || "Something";
      }
      eat() { return this.name + " is eating."; }
      greet() { return `Hello, I am ${this.name},I will${this.shouting}`; }
    }

    // class Cat {
    //   constructor(name) {
    //     this.name = name || "Cat";
    //   }
    // };
    // Cat.prototype = Animal.prototype;
    // 修复原型链指向问题，确保实例化后的对象能正确指向子类构造函数。
    // cat.prototype.constructor = Cat;
    // 实例化子类，继承了父类属性，并重写了父类原型属性。
    // const cat1 = new Cat("Tom");


    // 1.原型链继承 核心： 将父类的实例作为子类的原型
    // function Cat() { } // 子类构造函数
    // Cat.prototype = new Animal(); // 子类原型指向父类实例，即继承了父类
    // Cat.prototype.name = "Cat"; // 子类原型属性，重写父类原型属性，实现重写或添加父类方法的效果。

    // const cat = new Cat(); // 实例化子类，继承了父类属性，并重写了父类原型属性。
    // console.log(cat.greet()); // "Hello, I am Cat,I willSomething" 重写父类方法的效果。
    // console.log(cat.eat()); // "Cat is eating." 继承父类方法的效果。
    // console.log(cat instanceof Animal); // true 继承了父类构造函数的效果。
    // console.log(cat instanceof Cat); // true 继承了子类构造函数的效果。



    // 2.组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
    // function Cat(name) {
    //   Animal.call(this, name);
    // }
    // Cat.prototype = new Animal();
    // Cat.prototype.constructor = Cat;
    // var c1 = new Cat("Tom");



    // 3.借用构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
    // function Cat(name) {
    //   Animal.call(this, name);
    // }
    // var c1 = new Cat("Tom");



    // 4.实例继承 核心：为父类实例添加新特性，作为子类实例返回;
    // function Cat(name) {
    //   var instance = new Animal(name);
    //   instance.constructor = Cat;
    //   return instance;
    // }
    // var c1 = Cat("Tom");



    // 5.组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
    // function Cat(name) {
    //   Animal.call(this, name);
    // }
    // Cat.prototype = new Animal();
    // Cat.prototype.constructor = Cat;
    // var c1 = new Cat("Tom");



    // 6.寄生组合继承;
    // function Cat(name) {
    //   Animal.call(this, name);
    // }
    // (function () {
    //   var Super = function () { };
    //   Super.prototype = Animal.prototype;
    //   Cat.prototype = new Super();
    //   Cat.prototype.constructor = Cat;
    // })();
    // var c1 = new Cat("Tom");


  </script>


  <script>
    // 原型链继承：
    // function Parent() {
    //   this.name = 'parent';
    // }
    // Parent.prototype.sayName = function () {
    //   console.log(this.name);
    // };
    // function Child() {
    //   this.name = 'child';
    // }
    // // 设置Child的原型为Parent的实例
    // Child.prototype = new Parent();
    // var child = new Child();
    // child.sayName(); // 输出 'child'



    // 构造函数继承：
    // function Parent() {
    //   this.name = 'parent';
    // }
    // Parent.prototype.sayName = function () {
    //   console.log(this.name);
    // };
    // function Child() {
    //   Parent.call(this); // 使用Parent构造函数初始化Child实例
    //   this.name = 'child';
    // }
    // var child = new Child();
    // child.sayName(); // 输出 'child'



    // 组合继承（原型链继承 + 构造函数继承）：
    // function Parent() {
    //   this.name = 'parent';
    // }
    // Parent.prototype.sayName = function () {
    //   console.log(this.name);
    // };
    // function Child() {
    //   Parent.call(this); // 使用Parent构造函数初始化Child实例
    //   this.name = 'child';
    // }
    // // 设置Child的原型为Parent的实例
    // Child.prototype = new Parent();
    // Child.prototype.constructor = Child; // 修复构造函数指向
    // var child = new Child();
    // child.sayName(); // 输出 'child'



    // 寄生组合继承：
    // function Parent() {
    //   this.name = 'parent';
    // }
    // Parent.prototype.sayName = function () {
    //   console.log(this.name);
    // };
    // function Child() {
    //   Parent.call(this); // 使用Parent构造函数初始化Child实例
    //   this.name = 'child';
    // }
    // // 设置Child的原型为Parent的实例
    // Child.prototype = Object.create(Parent.prototype);
    // Child.prototype.constructor = Child; // 修复构造函数指向
    // var child = new Child();
    // child.sayName(); // 输出 'child'



    // ES6的class继承：
    // class Parent {
    //   constructor() {
    //     this.name = 'parent';
    //   }
    //   sayName() {
    //     console.log(this.name);
    //   }
    // }
    // class Child extends Parent {
    //   constructor() {
    //     super(); // 调用父类构造函数
    //     this.name = 'child';
    //   }
    // }
    // const child = new Child();
    // child.sayName(); // 输出 'child'





  </script>


</body>

</html>